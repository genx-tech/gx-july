{"version":3,"sources":["set.js"],"names":["_set","collection","keyPath","value","nodes","Array","isArray","concat","split","length","lastIndex","index","nested","key","next"],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMA,IAAI,GAAG,CAACC,UAAD,EAAaC,OAAb,EAAsBC,KAAtB,KAAgC;AACzC,MAAIF,UAAU,IAAI,IAAd,IAAsB,OAAOA,UAAP,KAAsB,QAAhD,EAA0D;AACtD,WAAOA,UAAP;AACH;;AAED,MAAIC,OAAO,IAAI,IAAf,EAAqB;AACjB,WAAOD,UAAP;AACH;;AAED,MAAIG,KAAK,GAAGC,KAAK,CAACC,OAAN,CAAcJ,OAAd,IAAyBA,OAAO,CAACK,MAAR,EAAzB,GAA4CL,OAAO,CAACM,KAAR,CAAc,GAAd,CAAxD;AACA,QAAMC,MAAM,GAAGL,KAAK,CAACK,MAArB;;AAEA,MAAIA,MAAM,GAAG,CAAb,EAAgB;AACZ,UAAMC,SAAS,GAAGD,MAAM,GAAG,CAA3B;AAEA,QAAIE,KAAK,GAAG,CAAZ;AACA,QAAIC,MAAM,GAAGX,UAAb;;AAEA,WAAOW,MAAM,IAAI,IAAV,IAAkBD,KAAK,GAAGD,SAAjC,EAA4C;AACxC,YAAMG,GAAG,GAAGT,KAAK,CAACO,KAAK,EAAN,CAAjB;AAEA,UAAIG,IAAI,GAAGF,MAAM,CAACC,GAAD,CAAjB;;AACA,UAAI,OAAOC,IAAP,KAAgB,QAApB,EAA8B;AAC1BA,QAAAA,IAAI,GAAGF,MAAM,CAACC,GAAD,CAAN,GAAc,EAArB;AACH;;AACDD,MAAAA,MAAM,GAAGE,IAAT;AACH;;AAEDF,IAAAA,MAAM,CAACR,KAAK,CAACM,SAAD,CAAN,CAAN,GAA2BP,KAA3B;AACH;;AAED,SAAOF,UAAP;AACH,CAhCD;;eAkCeD,I","sourcesContent":["/**\n * Set a value by dot-separated path or key array into a collection\n * Does not support '[i]', e.g. 'a[0].b.c' style accessor, use [ 'a',  0, 'b', 'c' ] instead, different from lodash/set\n * @alias  object.set\n * @param {Object} collection - The collection\n * @param {string} keyPath - A dot-separated path (dsp) or a key array, e.g. settings.xxx.yyy, or ['setting', 'xxx', 'yyy']\n * @param {Object} value - The default value if the path does not exist\n * @returns {*}\n */\nconst _set = (collection, keyPath, value) => {\n    if (collection == null || typeof collection !== 'object') {\n        return collection;\n    }\n\n    if (keyPath == null) {\n        return collection;\n    }\n\n    let nodes = Array.isArray(keyPath) ? keyPath.concat() : keyPath.split('.');\n    const length = nodes.length;\n\n    if (length > 0) {\n        const lastIndex = length - 1;\n\n        let index = 0;\n        let nested = collection;\n\n        while (nested != null && index < lastIndex) {\n            const key = nodes[index++];\n\n            let next = nested[key];\n            if (typeof next !== 'object') {\n                next = nested[key] = {};\n            }\n            nested = next;\n        }\n\n        nested[nodes[lastIndex]] = value;\n    }\n\n    return collection;\n};\n\nexport default _set;\n"]}