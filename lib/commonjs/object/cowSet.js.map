{"version":3,"sources":["cowSet.js"],"names":["cowSet","collection","keyPath","value","options","numberAsArrayIndex","keyPathSeparator","nodes","Array","isArray","concat","split","length","lastIndex","index","nested","key","next","nextKey","range","RANGE_INDEX","lastKey"],"mappings":";;;;;;;AAAA;;AACA;;AAEA;;;;;;;;AAEA;AACA,SAASA,MAAT,CAAgBC,UAAhB,EAA4BC,OAA5B,EAAqCC,KAArC,EAA4CC,OAA5C,EAAqD;AACjDA,EAAAA,OAAO,GAAG;AAAEC,IAAAA,kBAAkB,EAAE,IAAtB;AAA4BC,IAAAA,gBAAgB,EAAE,GAA9C;AAAmD,OAAGF;AAAtD,GAAV;;AAEA,MAAIH,UAAU,IAAI,IAAd,IAAsB,OAAOA,UAAP,KAAsB,QAAhD,EAA0D;AACtD,WAAOA,UAAP;AACH;;AAED,MAAIC,OAAO,IAAI,IAAf,EAAqB;AACjB,WAAOD,UAAP;AACH;;AAED,MAAIM,KAAK,GAAGC,KAAK,CAACC,OAAN,CAAcP,OAAd,IAAyBA,OAAO,CAACQ,MAAR,EAAzB,GAA4CR,OAAO,CAACS,KAAR,CAAcP,OAAO,CAACE,gBAAtB,CAAxD;AACA,QAAMM,MAAM,GAAGL,KAAK,CAACK,MAArB;;AAEA,MAAIA,MAAM,GAAG,CAAb,EAAgB;AACZ,UAAMC,SAAS,GAAGD,MAAM,GAAG,CAA3B;AAEA,QAAIE,KAAK,GAAG,CAAZ;AACA,QAAIC,MAAM,GAAG,qBAAOd,UAAP,CAAb;AACAA,IAAAA,UAAU,GAAGc,MAAb;;AAEA,WAAOA,MAAM,IAAI,IAAV,IAAkBD,KAAK,GAAGD,SAAjC,EAA4C;AACxC,YAAMG,GAAG,GAAGT,KAAK,CAACO,KAAK,EAAN,CAAjB;AAEA,UAAIG,IAAI,GAAGF,MAAM,CAACC,GAAD,CAAjB;;AACA,UAAIC,IAAI,IAAI,IAAR,IAAgB,OAAOA,IAAP,KAAgB,QAApC,EAA8C;AAC1C;AACA,cAAMC,OAAO,GAAGX,KAAK,CAACO,KAAD,CAArB;;AAEA,YAAIV,OAAO,CAACC,kBAAR,IAA8B,wBAAUa,OAAV,EAAmB;AAAEC,UAAAA,KAAK,EAAEC;AAAT,SAAnB,CAAlC,EAA8E;AAC1EH,UAAAA,IAAI,GAAG,mBAASF,MAAT,EAAiBC,GAAjB,EAAsB,EAAtB,EAA0BZ,OAAO,CAACC,kBAAlC,CAAP;AACH,SAFD,MAEO;AACHY,UAAAA,IAAI,GAAG,mBAASF,MAAT,EAAiBC,GAAjB,EAAsB,EAAtB,EAA0BZ,OAAO,CAACC,kBAAlC,CAAP;AACH;;AAEDU,QAAAA,MAAM,GAAGE,IAAT;AACH,OAXD,MAWO;AACHF,QAAAA,MAAM,CAACC,GAAD,CAAN,GAAc,qBAAOC,IAAP,CAAd;AACAF,QAAAA,MAAM,GAAGA,MAAM,CAACC,GAAD,CAAf;AACH;AACJ;;AAED,UAAMK,OAAO,GAAGd,KAAK,CAACM,SAAD,CAArB;AACA,uBAASE,MAAT,EAAiBM,OAAjB,EAA0BlB,KAA1B,EAAiCC,OAAO,CAACC,kBAAzC;AACH;;AAED,SAAOJ,UAAP;AACH;;eAEcD,M","sourcesContent":["import _clone from 'lodash/clone';\nimport isInteger, { RANGE_INDEX } from '../validators/isInteger';\n\nimport { addEntry } from './set';\n\n// copy on write set\nfunction cowSet(collection, keyPath, value, options) {\n    options = { numberAsArrayIndex: true, keyPathSeparator: '.', ...options };\n\n    if (collection == null || typeof collection !== 'object') {\n        return collection;\n    }\n\n    if (keyPath == null) {\n        return collection;\n    }\n\n    let nodes = Array.isArray(keyPath) ? keyPath.concat() : keyPath.split(options.keyPathSeparator);\n    const length = nodes.length;\n\n    if (length > 0) {\n        const lastIndex = length - 1;\n\n        let index = 0;\n        let nested = _clone(collection);\n        collection = nested;\n\n        while (nested != null && index < lastIndex) {\n            const key = nodes[index++];\n\n            let next = nested[key];\n            if (next == null || typeof next !== 'object') {\n                // peek next node, see if it is integer\n                const nextKey = nodes[index];\n\n                if (options.numberAsArrayIndex && isInteger(nextKey, { range: RANGE_INDEX })) {\n                    next = addEntry(nested, key, [], options.numberAsArrayIndex);\n                } else {\n                    next = addEntry(nested, key, {}, options.numberAsArrayIndex);\n                }\n\n                nested = next;\n            } else {\n                nested[key] = _clone(next);\n                nested = nested[key];\n            }            \n        }\n\n        const lastKey = nodes[lastIndex];\n        addEntry(nested, lastKey, value, options.numberAsArrayIndex);\n    }\n\n    return collection;\n}\n\nexport default cowSet;\n"]}