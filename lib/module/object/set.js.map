{"version":3,"names":["isPlainObject","_each","isInteger","RANGE_INDEX","addEntry","obj","key","value","numberAsArrayIndex","range","Array","isArray","index","parseInt","length","numToFill","i","push","undefined","_set","collection","keyPath","options","keyPathSeparator","v","k","nodes","concat","split","lastIndex","nested","next","nextKey","lastKey"],"sources":["set.js"],"sourcesContent":["import isPlainObject from './isPlainObject';\nimport _each from 'lodash/each';\nimport isInteger, { RANGE_INDEX } from '../validators/isInteger';\n\n// attention: since mobx will wrap the object in a Proxy, the source value will be different from the wrapped one\n// Here must return the obj[index] of obj[key], otherwise the child node will not be mounted to the root object\n\nexport const addEntry = (obj, key, value, numberAsArrayIndex) => {\n    if (numberAsArrayIndex && isInteger(key, { range: RANGE_INDEX })) {\n        if (Array.isArray(obj)) {\n            const index = parseInt(key, 10);\n\n            if (obj.length <= index) {\n                const numToFill = index - obj.length;\n                if (numToFill > 0) {\n                    for (let i = 0; i < numToFill; i++) {\n                        obj.push(undefined);\n                    }\n                }\n\n                obj.push(value);\n            } else {\n                obj[index] = value;\n            }\n\n            return obj[index];\n        }\n    }\n\n    obj[key] = value;\n    return obj[key];\n};\n\n/**\n * Set a value by dot-separated path or key array into a collection\n * Does not support '[i]', e.g. 'a[0].b.c' style accessor, use [ 'a',  0, 'b', 'c' ] instead, different from lodash/set\n * @alias  object.set\n * @param {Object} collection - The collection\n * @param {string} keyPath - A dot-separated path (dsp) or a key array, e.g. settings.xxx.yyy, or ['setting', 'xxx', 'yyy']\n * @param {Object} value - The default value if the path does not exist\n * @returns {*}\n */\nconst _set = (collection, keyPath, value, options) => {\n    options = { numberAsArrayIndex: true, keyPathSeparator: '.', ...options };\n\n    if (collection == null || typeof collection !== 'object') {\n        return collection;\n    }\n\n    if (keyPath == null) {\n        return collection;\n    }\n\n    if (isPlainObject(keyPath) && typeof value === 'undefined') {\n        // extract all key value pair and set\n        _each(keyPath, (v, k) => _set(collection, k, v, options));\n        return collection;\n    }\n\n    // break the path into nodes array\n    let nodes = Array.isArray(keyPath) ? keyPath.concat() : keyPath.split(options.keyPathSeparator);\n    const length = nodes.length;\n\n    if (length > 0) {\n        const lastIndex = length - 1;\n\n        let index = 0;\n        let nested = collection;\n\n        while (nested != null && index < lastIndex) {\n            const key = nodes[index++];\n\n            let next = nested[key];\n            if (next == null || typeof next !== 'object') {\n                // peek next node, see if it is integer\n                const nextKey = nodes[index];\n\n                if (options.numberAsArrayIndex && isInteger(nextKey, { range: RANGE_INDEX })) {\n                    next = addEntry(nested, key, [], options.numberAsArrayIndex);\n                } else {\n                    next = addEntry(nested, key, {}, options.numberAsArrayIndex);\n                }\n            }\n\n            nested = next;\n        }\n\n        const lastKey = nodes[lastIndex];\n        addEntry(nested, lastKey, value, options.numberAsArrayIndex);\n    }\n\n    return collection;\n};\n\nexport default _set;\n"],"mappings":"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"}