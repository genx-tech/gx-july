{"version":3,"sources":["set.js"],"names":["isPlainObject","_each","isInteger","RANGE_INDEX","addEntry","obj","key","value","numberAsArrayIndex","range","Array","isArray","index","parseInt","length","numToFill","i","push","undefined","_set","collection","keyPath","options","keyPathSeparator","v","k","nodes","concat","split","lastIndex","nested","next","nextKey","lastKey"],"mappings":"AAAA,OAAOA,aAAP,MAA0B,iBAA1B;AACA,OAAOC,KAAP,MAAkB,aAAlB;AACA,OAAOC,SAAP,IAAoBC,WAApB,QAAuC,yBAAvC;;AAEA,MAAMC,QAAQ,GAAG,CAACC,GAAD,EAAMC,GAAN,EAAWC,KAAX,EAAkBC,kBAAlB,KAAyC;AACtD,MAAIA,kBAAkB,IAAIN,SAAS,CAACI,GAAD,EAAM;AAAEG,IAAAA,KAAK,EAAEN;AAAT,GAAN,CAAnC,EAAkE;AAC9D,QAAIO,KAAK,CAACC,OAAN,CAAcN,GAAd,CAAJ,EAAwB;AACpB,YAAMO,KAAK,GAAGC,QAAQ,CAACP,GAAD,CAAtB;;AAEA,UAAID,GAAG,CAACS,MAAJ,IAAcF,KAAlB,EAAyB;AACrB,cAAMG,SAAS,GAAGH,KAAK,GAACP,GAAG,CAACS,MAA5B;;AACA,YAAIC,SAAS,GAAG,CAAhB,EAAmB;AACf,eAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,SAApB,EAA+BC,CAAC,EAAhC,EAAoC;AAChCX,YAAAA,GAAG,CAACY,IAAJ,CAASC,SAAT;AACH;AACJ;;AAEDb,QAAAA,GAAG,CAACY,IAAJ,CAASV,KAAT;AACA,eAAOA,KAAP;AACH;AACJ;AACJ;;AAEDF,EAAAA,GAAG,CAACC,GAAD,CAAH,GAAWC,KAAX;AACA,SAAOA,KAAP;AACH,CArBD;AAuBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMY,IAAI,GAAG,CAACC,UAAD,EAAaC,OAAb,EAAsBd,KAAtB,EAA6Be,OAA7B,KAAyC;AAClDA,EAAAA,OAAO,GAAG;AAAEd,IAAAA,kBAAkB,EAAE,IAAtB;AAA4Be,IAAAA,gBAAgB,EAAE,GAA9C;AAAmD,OAAGD;AAAtD,GAAV;;AAEA,MAAIF,UAAU,IAAI,IAAd,IAAsB,OAAOA,UAAP,KAAsB,QAAhD,EAA0D;AACtD,WAAOA,UAAP;AACH;;AAED,MAAIC,OAAO,IAAI,IAAf,EAAqB;AACjB,WAAOD,UAAP;AACH;;AAED,MAAIpB,aAAa,CAACqB,OAAD,CAAb,IAA0B,OAAOd,KAAP,KAAiB,WAA/C,EAA4D;AACxD;AACAN,IAAAA,KAAK,CAACoB,OAAD,EAAU,CAACG,CAAD,EAAIC,CAAJ,KAAUN,IAAI,CAACC,UAAD,EAAaK,CAAb,EAAgBD,CAAhB,EAAmBF,OAAnB,CAAxB,CAAL;;AACA,WAAOF,UAAP;AACH,GAfiD,CAiBlD;;;AACA,MAAIM,KAAK,GAAGhB,KAAK,CAACC,OAAN,CAAcU,OAAd,IAAyBA,OAAO,CAACM,MAAR,EAAzB,GAA4CN,OAAO,CAACO,KAAR,CAAcN,OAAO,CAACC,gBAAtB,CAAxD;AACA,QAAMT,MAAM,GAAGY,KAAK,CAACZ,MAArB;;AAEA,MAAIA,MAAM,GAAG,CAAb,EAAgB;AACZ,UAAMe,SAAS,GAAGf,MAAM,GAAG,CAA3B;AAEA,QAAIF,KAAK,GAAG,CAAZ;AACA,QAAIkB,MAAM,GAAGV,UAAb;;AAEA,WAAOU,MAAM,IAAI,IAAV,IAAkBlB,KAAK,GAAGiB,SAAjC,EAA4C;AACxC,YAAMvB,GAAG,GAAGoB,KAAK,CAACd,KAAK,EAAN,CAAjB;AAEA,UAAImB,IAAI,GAAGD,MAAM,CAACxB,GAAD,CAAjB;;AACA,UAAIyB,IAAI,IAAI,IAAR,IAAgB,OAAOA,IAAP,KAAgB,QAApC,EAA8C;AAC1C;AACA,cAAMC,OAAO,GAAGN,KAAK,CAACd,KAAD,CAArB;;AAEA,YAAIU,OAAO,CAACd,kBAAR,IAA8BN,SAAS,CAAC8B,OAAD,EAAU;AAAEvB,UAAAA,KAAK,EAAEN;AAAT,SAAV,CAA3C,EAA8E;AAC1E4B,UAAAA,IAAI,GAAG3B,QAAQ,CAAC0B,MAAD,EAASxB,GAAT,EAAc,EAAd,EAAkBgB,OAAO,CAACd,kBAA1B,CAAf;AACH,SAFD,MAEQ;AACJuB,UAAAA,IAAI,GAAG3B,QAAQ,CAAC0B,MAAD,EAASxB,GAAT,EAAc,EAAd,EAAkBgB,OAAO,CAACd,kBAA1B,CAAf;AACH;AACJ;;AAEDsB,MAAAA,MAAM,GAAGC,IAAT;AACH;;AAED,UAAME,OAAO,GAAGP,KAAK,CAACG,SAAD,CAArB;AACAzB,IAAAA,QAAQ,CAAC0B,MAAD,EAASG,OAAT,EAAkB1B,KAAlB,EAAyBe,OAAO,CAACd,kBAAjC,CAAR;AACH;;AAED,SAAOY,UAAP;AACH,CAlDD;;AAoDA,eAAeD,IAAf","sourcesContent":["import isPlainObject from './isPlainObject';\nimport _each from 'lodash/each'; \nimport isInteger, { RANGE_INDEX } from '../validators/isInteger';\n\nconst addEntry = (obj, key, value, numberAsArrayIndex) => {\n    if (numberAsArrayIndex && isInteger(key, { range: RANGE_INDEX })) {\n        if (Array.isArray(obj)) {\n            const index = parseInt(key);\n\n            if (obj.length <= index) {\n                const numToFill = index-obj.length;\n                if (numToFill > 0) {\n                    for (let i = 0; i < numToFill; i++) {\n                        obj.push(undefined);\n                    } \n                }                \n\n                obj.push(value);\n                return value;\n            } \n        }\n    }\n\n    obj[key] = value;\n    return value;\n}\n\n/**\n * Set a value by dot-separated path or key array into a collection\n * Does not support '[i]', e.g. 'a[0].b.c' style accessor, use [ 'a',  0, 'b', 'c' ] instead, different from lodash/set\n * @alias  object.set\n * @param {Object} collection - The collection\n * @param {string} keyPath - A dot-separated path (dsp) or a key array, e.g. settings.xxx.yyy, or ['setting', 'xxx', 'yyy']\n * @param {Object} value - The default value if the path does not exist\n * @returns {*}\n */\nconst _set = (collection, keyPath, value, options) => {\n    options = { numberAsArrayIndex: true, keyPathSeparator: '.', ...options };\n\n    if (collection == null || typeof collection !== 'object') {\n        return collection;\n    }\n\n    if (keyPath == null) {\n        return collection;\n    }\n\n    if (isPlainObject(keyPath) && typeof value === 'undefined') {\n        // extract all key value pair and set\n        _each(keyPath, (v, k) => _set(collection, k, v, options));\n        return collection;\n    }\n\n    // break the path into nodes array\n    let nodes = Array.isArray(keyPath) ? keyPath.concat() : keyPath.split(options.keyPathSeparator);\n    const length = nodes.length;\n\n    if (length > 0) {\n        const lastIndex = length - 1;\n\n        let index = 0;\n        let nested = collection;\n\n        while (nested != null && index < lastIndex) {\n            const key = nodes[index++];\n\n            let next = nested[key];\n            if (next == null || typeof next !== 'object') {\n                // peek next node, see if it is integer\n                const nextKey = nodes[index];\n\n                if (options.numberAsArrayIndex && isInteger(nextKey, { range: RANGE_INDEX })) {\n                    next = addEntry(nested, key, [], options.numberAsArrayIndex);\n                } else  {\n                    next = addEntry(nested, key, {}, options.numberAsArrayIndex);\n                }\n            } \n\n            nested = next;\n        }\n\n        const lastKey = nodes[lastIndex];\n        addEntry(nested, lastKey, value, options.numberAsArrayIndex);\n    }\n\n    return collection;\n};\n\nexport default _set;\n"]}