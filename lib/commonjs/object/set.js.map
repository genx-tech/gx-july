{"version":3,"sources":["set.js"],"names":["addEntry","obj","key","value","numberAsArrayIndex","range","RANGE_INDEX","Array","isArray","index","parseInt","length","numToFill","i","push","undefined","_set","collection","keyPath","options","keyPathSeparator","v","k","nodes","concat","split","lastIndex","nested","next","nextKey","lastKey"],"mappings":"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","sourcesContent":["import isPlainObject from './isPlainObject';\nimport _each from 'lodash/each';\nimport isInteger, { RANGE_INDEX } from '../validators/isInteger';\n\n// attention: since mobx will wrap the object in a Proxy, the source value will be different from the wrapped one\n// Here must return the obj[index] of obj[key], otherwise the child node will not be mounted to the root object\n\nexport const addEntry = (obj, key, value, numberAsArrayIndex) => {\n    if (numberAsArrayIndex && isInteger(key, { range: RANGE_INDEX })) {\n        if (Array.isArray(obj)) {\n            const index = parseInt(key, 10);\n\n            if (obj.length <= index) {\n                const numToFill = index - obj.length;\n                if (numToFill > 0) {\n                    for (let i = 0; i < numToFill; i++) {\n                        obj.push(undefined);\n                    }\n                }\n\n                obj.push(value);\n            } else {\n                obj[index] = value;\n            }\n\n            return obj[index];\n        }\n    }\n\n    obj[key] = value;\n    return obj[key];\n};\n\n/**\n * Set a value by dot-separated path or key array into a collection\n * Does not support '[i]', e.g. 'a[0].b.c' style accessor, use [ 'a',  0, 'b', 'c' ] instead, different from lodash/set\n * @alias  object.set\n * @param {Object} collection - The collection\n * @param {string} keyPath - A dot-separated path (dsp) or a key array, e.g. settings.xxx.yyy, or ['setting', 'xxx', 'yyy']\n * @param {Object} value - The default value if the path does not exist\n * @returns {*}\n */\nconst _set = (collection, keyPath, value, options) => {\n    options = { numberAsArrayIndex: true, keyPathSeparator: '.', ...options };\n\n    if (collection == null || typeof collection !== 'object') {\n        return collection;\n    }\n\n    if (keyPath == null) {\n        return collection;\n    }\n\n    if (isPlainObject(keyPath) && typeof value === 'undefined') {\n        // extract all key value pair and set\n        _each(keyPath, (v, k) => _set(collection, k, v, options));\n        return collection;\n    }\n\n    // break the path into nodes array\n    let nodes = Array.isArray(keyPath) ? keyPath.concat() : keyPath.split(options.keyPathSeparator);\n    const length = nodes.length;\n\n    if (length > 0) {\n        const lastIndex = length - 1;\n\n        let index = 0;\n        let nested = collection;\n\n        while (nested != null && index < lastIndex) {\n            const key = nodes[index++];\n\n            let next = nested[key];\n            if (next == null || typeof next !== 'object') {\n                // peek next node, see if it is integer\n                const nextKey = nodes[index];\n\n                if (options.numberAsArrayIndex && isInteger(nextKey, { range: RANGE_INDEX })) {\n                    next = addEntry(nested, key, [], options.numberAsArrayIndex);\n                } else {\n                    next = addEntry(nested, key, {}, options.numberAsArrayIndex);\n                }\n            }\n\n            nested = next;\n        }\n\n        const lastKey = nodes[lastIndex];\n        addEntry(nested, lastKey, value, options.numberAsArrayIndex);\n    }\n\n    return collection;\n};\n\nexport default _set;\n"]}