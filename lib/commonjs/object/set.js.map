{"version":3,"sources":["set.js"],"names":["_set","collection","keyPath","value","Object","assign","nodes","Array","isArray","concat","split","length","lastIndex","index","nested","key","next"],"mappings":";;;;;;;AAAA;;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMA,IAAI,GAAG,CAACC,UAAD,EAAaC,OAAb,EAAsBC,KAAtB,KAAgC;AACzC,MAAIF,UAAU,IAAI,IAAd,IAAsB,CAAC,4BAAcA,UAAd,CAA3B,EAAsD;AAClD,WAAOA,UAAP;AACH;;AAED,MAAIC,OAAO,IAAI,IAAf,EAAqB;AACjB,WAAOD,UAAP;AACH;;AAED,MAAI,4BAAcC,OAAd,KAA0B,OAAOC,KAAP,KAAiB,WAA/C,EAA4D;AACxD,WAAOC,MAAM,CAACC,MAAP,CAAcJ,UAAd,EAA0BC,OAA1B,CAAP;AACH;;AAED,MAAII,KAAK,GAAGC,KAAK,CAACC,OAAN,CAAcN,OAAd,IAAyBA,OAAO,CAACO,MAAR,EAAzB,GAA4CP,OAAO,CAACQ,KAAR,CAAc,GAAd,CAAxD;AACA,QAAMC,MAAM,GAAGL,KAAK,CAACK,MAArB;;AAEA,MAAIA,MAAM,GAAG,CAAb,EAAgB;AACZ,UAAMC,SAAS,GAAGD,MAAM,GAAG,CAA3B;AAEA,QAAIE,KAAK,GAAG,CAAZ;AACA,QAAIC,MAAM,GAAGb,UAAb;;AAEA,WAAOa,MAAM,IAAI,IAAV,IAAkBD,KAAK,GAAGD,SAAjC,EAA4C;AACxC,YAAMG,GAAG,GAAGT,KAAK,CAACO,KAAK,EAAN,CAAjB;AAEA,UAAIG,IAAI,GAAGF,MAAM,CAACC,GAAD,CAAjB;;AACA,UAAI,CAAC,4BAAcC,IAAd,CAAL,EAA0B;AACtBA,QAAAA,IAAI,GAAGF,MAAM,CAACC,GAAD,CAAN,GAAc,EAArB;AACH;;AACDD,MAAAA,MAAM,GAAGE,IAAT;AACH;;AAEDF,IAAAA,MAAM,CAACR,KAAK,CAACM,SAAD,CAAN,CAAN,GAA2BT,KAA3B;AACH;;AAED,SAAOF,UAAP;AACH,CApCD;;eAsCeD,I","sourcesContent":["import isPlainObject from './isPlainObject';\n\n/**\n * Set a value by dot-separated path or key array into a collection\n * Does not support '[i]', e.g. 'a[0].b.c' style accessor, use [ 'a',  0, 'b', 'c' ] instead, different from lodash/set\n * @alias  object.set\n * @param {Object} collection - The collection\n * @param {string} keyPath - A dot-separated path (dsp) or a key array, e.g. settings.xxx.yyy, or ['setting', 'xxx', 'yyy']\n * @param {Object} value - The default value if the path does not exist\n * @returns {*}\n */\nconst _set = (collection, keyPath, value) => {\n    if (collection == null || !isPlainObject(collection)) {\n        return collection;\n    }\n\n    if (keyPath == null) {\n        return collection;\n    }\n\n    if (isPlainObject(keyPath) && typeof value === 'undefined') {\n        return Object.assign(collection, keyPath);\n    }\n\n    let nodes = Array.isArray(keyPath) ? keyPath.concat() : keyPath.split('.');\n    const length = nodes.length;\n\n    if (length > 0) {\n        const lastIndex = length - 1;\n\n        let index = 0;\n        let nested = collection;\n\n        while (nested != null && index < lastIndex) {\n            const key = nodes[index++];\n\n            let next = nested[key];\n            if (!isPlainObject(next)) {\n                next = nested[key] = {};\n            }\n            nested = next;\n        }\n\n        nested[nodes[lastIndex]] = value;\n    }\n\n    return collection;\n};\n\nexport default _set;\n"]}